/**
 * Создание полноценного курса "Prompt-инжиниринг для GPT-моделей"
 * с профессиональным контентом, примерами кода и практическими заданиями
 */

import { db } from '../db.js';
import { 
  courses, 
  courseModules, 
  lessons, 
  assignments 
} from '../../shared/schema.js';
import { eq } from 'drizzle-orm';

// Профессиональный контент курса
const courseContent = {
  modules: [
    {
      title: "Основы работы с LLM и структура промптов",
      description: "Понимание архитектуры языковых моделей и базовых принципов создания эффективных запросов",
      order_index: 1,
      lessons: [
        {
          title: "Архитектура и принципы работы GPT-моделей",
          content: `# Архитектура и принципы работы GPT-моделей

## Что такое GPT и как он работает

**GPT (Generative Pre-trained Transformer)** — это семейство языковых моделей, основанных на архитектуре трансформера. Понимание того, как работает модель "под капотом", критически важно для создания эффективных промптов.

### Ключевые концепции

#### 1. Токенизация
GPT обрабатывает текст не как слова, а как **токены** — части слов или целые слова.

\`\`\`python
# Пример токенизации
text = "Привет, как дела?"
# Может быть разбито на токены:
# ["Прив", "ет", ",", " как", " дела", "?"]
\`\`\`

**Важно помнить:**
- Русские слова обычно занимают больше токенов, чем английские
- Специальные символы и числа могут токенизироваться неожиданно
- Лимит контекста измеряется в токенах (например, 4096 токенов для GPT-3.5)

#### 2. Контекстное окно
Модель "видит" только определенное количество токенов из вашего запроса и предыдущих сообщений.

\`\`\`
[Системный промпт] + [История диалога] + [Текущий запрос] = Контекст
\`\`\`

#### 3. Предсказание следующего токена
GPT работает по принципу предсказания следующего наиболее вероятного токена:

\`\`\`
"Столица России это" → "Москва" (высокая вероятность)
"Столица России это" → "Санкт-Петербург" (низкая вероятность)
\`\`\`

### Параметры генерации

#### Temperature (Температура)
Контролирует "креативность" ответов:
- **0.0-0.3**: Детерминированные, точные ответы
- **0.7-1.0**: Креативные, разнообразные ответы
- **1.0+**: Хаотичные, непредсказуемые ответы

#### Top-p (Nucleus sampling)
Ограничивает выбор токенов:
- **0.1**: Очень ограниченный выбор
- **0.9**: Широкий выбор токенов

### Практический пример

\`\`\`python
import openai

# Настройка параметров для разных задач
def creative_writing(prompt):
    return openai.ChatCompletion.create(
        model="gpt-4",
        messages=[{"role": "user", "content": prompt}],
        temperature=0.8,  # Высокая креативность
        top_p=0.9
    )

def factual_qa(prompt):
    return openai.ChatCompletion.create(
        model="gpt-4", 
        messages=[{"role": "user", "content": prompt}],
        temperature=0.1,  # Низкая креативность
        top_p=0.1
    )
\`\`\`

## Ограничения и особенности

### 1. Cutoff дата знаний
Модель обучена на данных до определенной даты и не знает о событиях после нее.

### 2. Галлюцинации
Модель может "выдумывать" факты, особенно для:
- Малоизвестных персон или событий
- Технических деталей
- Статистических данных

### 3. Контекстные ограничения
- Модель не может "помнить" диалоги за пределами сессии
- Длинные документы могут не поместиться в контекст

## Выводы

Понимание архитектуры GPT помогает:
- Структурировать промпты для максимальной эффективности
- Выбирать правильные параметры генерации
- Предсказывать поведение модели
- Избегать типичных ошибок в промпт-инжиниринге`,
          type: "article",
          order_index: 1,
          duration: 20
        },
        {
          title: "Структура эффективного промпта",
          content: `# Структура эффективного промпта

## Анатомия промпта

Эффективный промпт состоит из нескольких ключевых компонентов, каждый из которых выполняет свою функцию:

\`\`\`
[РОЛЬ] + [КОНТЕКСТ] + [ЗАДАЧА] + [ФОРМАТ] + [ОГРАНИЧЕНИЯ] = Эффективный промпт
\`\`\`

### 1. Роль (Role)
Определите, кем должна "притворяться" модель:

\`\`\`
❌ Плохо: "Расскажи про маркетинг"

✅ Хорошо: "Ты опытный маркетинг-директор с 10-летним стажем в B2B сфере. Расскажи про..."
\`\`\`

**Примеры ролей:**
- Эксперт в определенной области
- Преподаватель или ментор  
- Аналитик или консультант
- Творческий писатель
- Технический специалист

### 2. Контекст (Context)
Предоставьте всю необходимую информацию:

\`\`\`python
prompt = f"""
Контекст: Я разрабатываю мобильное приложение для изучения языков.
Целевая аудитория: студенты 18-25 лет.
Бюджет: $50,000
Срок: 6 месяцев

Задача: Составь план монетизации приложения.
"""
\`\`\`

### 3. Задача (Task)
Четко сформулируйте, что именно нужно сделать:

\`\`\`
❌ Неясно: "Помоги с кодом"
✅ Конкретно: "Оптимизируй этот Python-код для обработки больших JSON файлов"
\`\`\`

### 4. Формат (Format)
Укажите желаемый формат ответа:

\`\`\`
Формат ответа:
1. Краткое резюме (2-3 предложения)
2. Детальный анализ с примерами
3. Практические рекомендации в виде нумерованного списка
4. Заключение с прогнозом
\`\`\`

### 5. Ограничения (Constraints)
Установите четкие границы:

\`\`\`
Ограничения:
- Ответ не более 500 слов
- Используй только проверенные источники
- Не включай спекулятивную информацию
- Сосредоточься на практических решениях
\`\`\`

## Шаблоны промптов

### Шаблон 1: Аналитическая задача
\`\`\`
Ты [РОЛЬ: аналитик/эксперт в области X].

Контекст: [ОПИСАНИЕ СИТУАЦИИ]

Задача: Проанализируй [ОБЪЕКТ АНАЛИЗА] и определи [ЦЕЛЬ АНАЛИЗА].

Структура ответа:
1. Ключевые факторы
2. Анализ каждого фактора
3. Выводы и рекомендации

Ограничения: [СПЕЦИФИЧЕСКИЕ ТРЕБОВАНИЯ]
\`\`\`

### Шаблон 2: Творческая задача
\`\`\`
Ты креативный [РОЛЬ: писатель/дизайнер/маркетолог].

Создай [ПРОДУКТ: статью/дизайн/кампанию] на тему "[ТЕМА]".

Требования:
- Целевая аудитория: [ОПИСАНИЕ]
- Стиль: [ФОРМАЛЬНЫЙ/НЕФОРМАЛЬНЫЙ/И т.д.]
- Объем: [КОЛИЧЕСТВО СЛОВ/СТРАНИЦ]
- Ключевые моменты: [СПИСОК]

Избегай: [НЕЖЕЛАТЕЛЬНЫЕ ЭЛЕМЕНТЫ]
\`\`\`

### Шаблон 3: Техническая задача
\`\`\`
Ты опытный [РОЛЬ: разработчик/инженер] со специализацией в [ОБЛАСТЬ].

Проблема: [ОПИСАНИЕ ТЕХНИЧЕСКОЙ ПРОБЛЕМЫ]

Контекст:
- Технологический стек: [СПИСОК ТЕХНОЛОГИЙ]
- Ограничения: [ПРОИЗВОДИТЕЛЬНОСТЬ/ПАМЯТЬ/И т.д.]
- Требования: [ФУНКЦИОНАЛЬНЫЕ ТРЕБОВАНИЯ]

Предоставь:
1. Анализ проблемы
2. Возможные решения (минимум 3)
3. Рекомендуемое решение с обоснованием
4. Пример кода (если применимо)
\`\`\`

## Техники улучшения промптов

### 1. Постепенное уточнение (Progressive prompting)
\`\`\`python
# Начальный промпт
prompt_v1 = "Создай план тренировок"

# Уточненный промпт
prompt_v2 = "Создай план тренировок для набора мышечной массы"

# Детализированный промпт
prompt_v3 = """
Ты персональный тренер с сертификацией NASM.
Создай 12-недельный план тренировок для набора мышечной массы.

Параметры клиента:
- Возраст: 25 лет
- Опыт: начинающий (3 месяца)
- Цель: +8 кг мышечной массы
- Доступное время: 4 тренировки в неделю по 1.5 часа
- Оборудование: полный тренажерный зал

Структура плана:
1. Разминка (10 мин)
2. Основная часть (70 мин)
3. Заминка (10 мин)

Включи прогрессию нагрузок и периодизацию.
"""
\`\`\`

### 2. Использование примеров (Few-shot prompting)
\`\`\`
Классифицируй эмоциональную окраску отзывов:

Пример 1:
Отзыв: "Отличный продукт, рекомендую!"
Эмоция: Положительная

Пример 2:
Отзыв: "Ужасное качество, деньги на ветер"
Эмоция: Отрицательная

Теперь классифицируй:
Отзыв: "Товар неплохой, но есть недостатки"
Эмоция: ?
\`\`\`

### 3. Цепочка размышлений (Chain of Thought)
\`\`\`
Реши задачу пошагово:

Задача: В магазине было 100 яблок. Утром продали 30%, днем еще 25 яблок. Сколько осталось?

Думай пошагово:
1. Сначала определи сколько продали утром
2. Затем посчитай общее количество проданных яблок
3. Наконец, вычти из исходного количества
\`\`\`

## Распространенные ошибки

### ❌ Слишком общие запросы
\`\`\`
"Расскажи про искусственный интеллект"
\`\`\`

### ❌ Отсутствие контекста
\`\`\`
"Как это исправить?" (без указания что именно нужно исправить)
\`\`\`

### ❌ Противоречивые инструкции
\`\`\`
"Будь кратким, но детально опиши все аспекты проблемы"
\`\`\`

### ❌ Неясные ожидания
\`\`\`
"Сделай это лучше" (без определения критериев "лучше")
\`\`\`

## Контрольный чек-лист эффективного промпта

- [ ] Роль четко определена
- [ ] Контекст полный и релевантный  
- [ ] Задача сформулирована конкретно
- [ ] Формат ответа указан
- [ ] Ограничения установлены
- [ ] Нет противоречий в инструкциях
- [ ] Примеры добавлены (если нужно)
- [ ] Ожидания реалистичны

Помните: хороший промпт — это инвестиция времени, которая окупается качеством результата.`,
          type: "article",
          order_index: 2,
          duration: 25
        }
      ]
    },
    {
      title: "Роли и контекст в промпт-инжиниринге",
      description: "Изучение техник задания ролей, создания контекста и управления поведением модели",
      order_index: 2,
      lessons: [
        {
          title: "Системные роли и персоны",
          content: `# Системные роли и персоны в GPT

## Концепция ролей

Одна из самых мощных техник промпт-инжиниринга — это **назначение роли** языковой модели. Роль задает контекст, стиль общения и уровень экспертизы ответов.

### Зачем нужны роли?

1. **Специализация знаний** — модель фокусируется на конкретной области
2. **Согласованность стиля** — ответы в едином тоне и формате
3. **Улучшение качества** — более релевантные и точные ответы
4. **Контроль поведения** — предсказуемые реакции модели

## Типы ролей

### 1. Профессиональные роли

#### Эксперт-консультант
\`\`\`
Ты ведущий специалист по кибербезопасности с 15-летним опытом работы в крупных IT-компаниях. Твоя специализация — защита корпоративных сетей и анализ угроз. Ты известен своими практическими решениями и способностью объяснять сложные концепции простым языком.

При ответе на вопросы:
- Ссылайся на реальные кейсы и примеры
- Указывай на конкретные инструменты и технологии
- Предупреждай о потенциальных рисках
- Предлагай поэтапный план действий
\`\`\`

#### Наставник-преподаватель
\`\`\`
Ты опытный преподаватель программирования с 10-летним стажем. Твоя сильная сторона — умение адаптировать объяснения под уровень студента и находить подходящие аналогии для сложных концепций.

Твой стиль обучения:
- Начинай с простых понятий, постепенно усложняя
- Используй практические примеры и аналогии
- Задавай уточняющие вопросы для проверки понимания
- Поощряй самостоятельное мышление
- Предлагай дополнительные задания для закрепления
\`\`\`

### 2. Творческие роли

#### Креативный директор
\`\`\`
Ты креативный директор рекламного агентства с международной наградой "Каннские львы". Твоя специальность — создание вирусных кампаний для молодежной аудитории. Ты известен нестандартным мышлением и способностью найти эмоциональную связь с любой аудиторией.

Твой подход:
- Думай нестандартно и провокационно
- Ищи эмоциональные триггеры
- Учитывай тренды и культурный контекст
- Предлагай несколько креативных концепций
- Объясняй психологию за каждым решением
\`\`\`

### 3. Аналитические роли

#### Бизнес-аналитик
\`\`\`
Ты старший бизнес-аналитик международной консалтинговой компании. Твоя специализация — анализ эффективности бизнес-процессов и поиск точек роста. Ты славишься структурированным подходом и способностью находить инсайты в больших объемах данных.

Твоя методология:
- Всегда начинай с определения метрик успеха
- Структурируй анализ по фреймворкам (SWOT, 5 Forces, и т.д.)
- Подкрепляй выводы конкретными цифрами
- Предлагай измеримые рекомендации
- Учитывай риски и ограничения
\`\`\`

## Продвинутые техники создания ролей

### 1. Многослойная персона

\`\`\`python
system_prompt = """
Ты доктор Алекс Стоун — нейрохирург с 20-летним опытом и параллельно исследователь в области ИИ в медицине.

Личность:
- Аналитический склад ума, методичность
- Осторожность в прогнозах, но открытость к инновациям  
- Способность объяснять сложное простыми словами
- Этическая ответственность в вопросах здоровья

Опыт:
- 2000+ операций на головном мозге
- 50+ научных публикаций по нейроинженерии
- Консультант 3 стартапов в области медицинского ИИ
- Лектор в Гарвардской медицинской школе

Стиль общения:
- Профессиональный, но доступный
- Использует медицинскую терминологию с пояснениями
- Ссылается на клинические исследования
- Всегда указывает на ограничения и противопоказания
"""
\`\`\`

### 2. Адаптивная роль

\`\`\`
Ты ментор по программированию, который адаптирует свой стиль под уровень собеседника:

Для новичков (0-1 год опыта):
- Используй простые аналогии и метафоры
- Объясняй каждый шаг подробно
- Предлагай небольшие практические задания
- Подбадривай и мотивируй

Для опытных разработчиков (2-5 лет):
- Фокусируйся на лучших практиках и паттернах
- Обсуждай архитектурные решения  
- Предлагай оптимизации и альтернативы
- Затрагивай производительность и масштабируемость

Для экспертов (5+ лет):
- Обсуждай архитектурные тренды и новые технологии
- Рассматривай trade-offs в принятии решений
- Говори о метриках и мониторинге
- Обсуждай командную работу и менторство
\`\`\`

### 3. Роль с ограничениями

\`\`\`
Ты финансовый советник, специализирующийся на инвестициях для среднего класса.

Твои принципы:
✅ МОЖЕШЬ:
- Объяснять базовые принципы инвестирования
- Рассказывать о типах активов и их рисках
- Предлагать общие стратегии диверсификации
- Обучать финансовой грамотности

❌ НЕ МОЖЕШЬ:
- Давать конкретные инвестиционные советы
- Рекомендовать конкретные акции или фонды
- Прогнозировать движение рынков
- Заменять персональную консультацию со специалистом

Всегда напоминай: "Это общая информация, не персональный совет. Обязательно консультируйся с лицензированным финансовым консультантом."
\`\`\`

## Контекстные модификаторы

### Временной контекст
\`\`\`
Ты журналист 1960-х годов, освещающий космическую гонку между СССР и США. Пиши в стиле того времени, используй терминологию эпохи и отражай дух времени.
\`\`\`

### Культурный контекст
\`\`\`
Ты маркетолог, специализирующийся на российском рынке. Учитывай культурные особенности, менталитет, праздники и тренды, специфичные для России.
\`\`\`

### Отраслевой контекст
\`\`\`
Ты продуктовый менеджер в SaaS-компании, разрабатывающей B2B решения для малого и среднего бизнеса. Твой опыт сосредоточен на продуктах с моделью подписки и фрикшн-анализе.
\`\`\`

## Практические примеры

### Пример 1: Техническая роль

\`\`\`python
# Роль DevOps-инженера
role_prompt = """
Ты senior DevOps-инженер с опытом работы в высоконагруженных системах. 
Твоя специализация — контейнеризация, Kubernetes, и CI/CD пайплайны.

При решении задач:
1. Сначала анализируй требования к масштабируемости
2. Учитывай принципы Infrastructure as Code
3. Предлагай решения с автоматизацией
4. Думай о мониторинге и алертинге
5. Рассматривай вопросы безопасности
"""

user_query = "Как настроить деплой Node.js приложения?"

# Ответ будет структурированным и профессиональным
\`\`\`

### Пример 2: Креативная роль

\`\`\`python
# Роль UX/UI дизайнера
role_prompt = """
Ты UX/UI дизайнер с опытом работы в финтех-стартапах. 
Ты специализируешься на создании интуитивных интерфейсов для сложных финансовых продуктов.

Твой подход:
- User-centered design
- Принцип "mobile-first"
- Доступность (accessibility)
- Психология восприятия цветов и форм
- A/B тестирование дизайнерских решений
"""

user_query = "Как спроектировать форму регистрации для банковского приложения?"
\`\`\`

## Оценка эффективности ролей

### Метрики качества роли:

1. **Консистентность** — ответы в едином стиле
2. **Релевантность** — соответствие экспертизе роли
3. **Глубина** — уровень детализации ответов
4. **Практичность** — применимость советов

### Тестирование роли:

\`\`\`python
def test_role_consistency(role_prompt, test_questions):
    """
    Тестирует консистентность роли на наборе вопросов
    """
    results = []
    for question in test_questions:
        response = get_gpt_response(role_prompt + question)
        results.append({
            'question': question,
            'response': response,
            'maintains_role': check_role_consistency(response, role_prompt)
        })
    return results
\`\`\`

## Заключение

Правильно созданная роль — это фундамент эффективного промпт-инжиниринга. Она определяет:

- **Качество ответов** — уровень экспертизы
- **Стиль общения** — тон и подход
- **Фокус внимания** — приоритеты в ответе
- **Предсказуемость** — консистентность результатов

**Ключевые принципы:**
1. Роль должна быть специфичной, не общей
2. Включайте контекст опыта и экспертизы
3. Определяйте стиль и принципы работы
4. Тестируйте роль на разных типах вопросов
5. Итерируйте и улучшайте роль на основе результатов`,
          type: "article",
          order_index: 1,
          duration: 30
        }
      ]
    },
    {
      title: "Chain-of-Thought и техники улучшения ответов",
      description: "Продвинутые методы структурирования мышления модели и получения качественных ответов",
      order_index: 3,
      lessons: [
        {
          title: "Chain-of-Thought: пошаговое мышление",
          content: `# Chain-of-Thought: пошаговое мышление

## Что такое Chain-of-Thought (CoT)

**Chain-of-Thought** — это техника промпт-инжиниринга, которая заставляет языковую модель "думать вслух", разбивая сложные задачи на последовательные логические шаги.

### Зачем это нужно?

1. **Улучшение точности** — снижение ошибок в рассуждениях
2. **Прозрачность логики** — можно проследить ход мышления
3. **Решение сложных задач** — разбиение на подзадачи
4. **Обучение и объяснение** — демонстрация процесса решения

## Базовый Chain-of-Thought

### Простой пример

❌ **Без CoT:**
\`\`\`
Вопрос: Если в корзине 15 яблок, и я съел 1/3, сколько осталось?
Ответ: 10 яблок
\`\`\`

✅ **С CoT:**
\`\`\`
Вопрос: Если в корзине 15 яблок, и я съел 1/3, сколько осталось?

Думаю пошагово:
1. В корзине было 15 яблок
2. Я съел 1/3 от общего количества
3. 1/3 от 15 = 15 ÷ 3 = 5 яблок
4. Осталось: 15 - 5 = 10 яблок

Ответ: 10 яблок
\`\`\`

### Шаблон CoT
\`\`\`
Задача: [ОПИСАНИЕ ЗАДАЧИ]

Решаю пошагово:
1. [Первый шаг анализа]
2. [Второй шаг]
3. [Третий шаг]
...
n. [Финальный вывод]

Ответ: [РЕЗУЛЬТАТ]
\`\`\`

## Продвинутые техники CoT

### 1. Few-Shot Chain-of-Thought

Предоставляем модели несколько примеров с пошаговым решением:

\`\`\`python
prompt = """
Реши задачи, показывая пошаговое мышление:

Пример 1:
Задача: В магазине скидка 25%. Товар стоил 1200 рублей. Какая финальная цена?
Решение:
1. Исходная цена: 1200 рублей
2. Скидка: 25% = 0.25
3. Размер скидки: 1200 × 0.25 = 300 рублей
4. Финальная цена: 1200 - 300 = 900 рублей
Ответ: 900 рублей

Пример 2:
Задача: Компания увеличила продажи на 40% в первом квартале и на 20% во втором. На сколько процентов выросли продажи за полугодие?
Решение:
1. Пусть изначальные продажи = 100 единиц
2. После первого квартала: 100 × 1.4 = 140 единиц
3. После второго квартала: 140 × 1.2 = 168 единиц
4. Общий рост: 168 - 100 = 68 единиц
5. Процент роста: 68/100 × 100% = 68%
Ответ: 68%

Теперь реши:
Задача: [НОВАЯ ЗАДАЧА]
"""
\`\`\`

### 2. Zero-Shot Chain-of-Thought

Просто добавляем фразу "Думай пошагово":

\`\`\`python
# Простой способ активировать CoT
prompt = """
Задача: Определи оптимальную стратегию ценообразования для нового SaaS продукта.

Думай пошагово и учитывай все важные факторы.
"""
\`\`\`

### 3. Структурированный CoT

Задаем конкретную структуру рассуждения:

\`\`\`python
prompt = """
Анализируй бизнес-проблему по следующей схеме:

1. ОПРЕДЕЛЕНИЕ ПРОБЛЕМЫ
   - В чем заключается главная проблема?
   - Какие симптомы мы наблюдаем?

2. АНАЛИЗ ПРИЧИН
   - Какие факторы могли привести к этой проблеме?
   - Есть ли связанные проблемы?

3. ВОЗМОЖНЫЕ РЕШЕНИЯ
   - Какие варианты решения существуют?
   - Каковы плюсы и минусы каждого?

4. РЕКОМЕНДАЦИЯ
   - Какое решение рекомендуешь и почему?
   - Какие первые шаги нужно предпринять?

Проблема: Наша команда разработки не успевает выпускать фичи в срок.
"""
\`\`\`

## Специализированные техники

### 1. Tree of Thoughts (ToT)

Исследование множественных путей решения:

\`\`\`python
prompt = """
Реши задачу, рассматривая несколько альтернативных подходов:

Задача: Как увеличить конверсию интернет-магазина с 2% до 5%?

Подход 1: Оптимизация пользовательского опыта
- Анализ: [детальный анализ]
- Действия: [конкретные шаги]
- Ожидаемый результат: [прогноз]

Подход 2: Улучшение маркетинговых воронок
- Анализ: [детальный анализ]
- Действия: [конкретные шаги]
- Ожидаемый результат: [прогноз]

Подход 3: Персонализация и таргетинг
- Анализ: [детальный анализ]
- Действия: [конкретные шаги]
- Ожидаемый результат: [прогноз]

Сравни подходы и выбери оптимальную стратегию.
"""
\`\`\`

### 2. Self-Reflection CoT

Модель проверяет свои рассуждения:

\`\`\`python
prompt = """
Реши задачу пошагово, а затем проверь свое решение:

Задача: [ОПИСАНИЕ]

ШАГ 1: Первоначальное решение
[Решение пошагово]

ШАГ 2: Проверка решения
- Правильно ли я понял задачу?
- Есть ли ошибки в вычислениях?
- Учел ли я все условия?
- Является ли ответ разумным?

ШАГ 3: Финальный ответ
[Исправленное решение при необходимости]
"""
\`\`\`

### 3. Metacognitive CoT

Размышление о процессе мышления:

\`\`\`python
prompt = """
Реши задачу, анализируя собственный процесс мышления:

Задача: Спланируй маркетинговую кампанию для запуска нового продукта

1. ПЛАНИРОВАНИЕ ПОДХОДА
   - Какую стратегию мышления я выберу?
   - Какие вопросы нужно задать себе?
   - В каком порядке буду анализировать?

2. ПРОЦЕСС РЕШЕНИЯ
   - [Пошаговое решение задачи]
   - [Комментарии о том, почему выбираю тот или иной ход мыслей]

3. МОНИТОРИНГ МЫШЛЕНИЯ
   - Правильный ли путь я выбрал?
   - Нужно ли изменить подход?
   - Какие предположения я делаю?

4. ФИНАЛЬНАЯ ОЦЕНКА
   - Насколько я уверен в решении?
   - Что могло пойти не так в моих рассуждениях?
"""
\`\`\`

## Практические применения

### 1. Анализ данных

\`\`\`python
data_analysis_cot = """
Проанализируй следующие данные о продажах пошагово:

Данные: [ДАННЫЕ]

Анализ:
1. ПЕРВИЧНЫЙ ОБЗОР
   - Какие основные тренды я вижу?
   - Есть ли очевидные аномалии?

2. СТАТИСТИЧЕСКИЙ АНАЛИЗ
   - Какие метрики наиболее важны?
   - Как данные соотносятся с бенчмарками?

3. ПОИСК ИНСАЙТОВ
   - Какие паттерны указывают на проблемы?
   - Какие возможности для роста я вижу?

4. РЕКОМЕНДАЦИИ
   - Какие действия предлагаю на основе анализа?
   - Как измерить успех изменений?
"""
\`\`\`

### 2. Стратегическое планирование

\`\`\`python
strategic_cot = """
Разработай стратегию входа на новый рынок:

1. АНАЛИЗ РЫНКА
   - Размер и потенциал рынка
   - Ключевые игроки и их позиции
   - Барьеры для входа

2. АНАЛИЗ РЕСУРСОВ
   - Наши сильные стороны
   - Ограничения и риски
   - Необходимые инвестиции

3. СТРАТЕГИЧЕСКИЕ ОПЦИИ
   - Возможные подходы к входу
   - Оценка каждого подхода
   - Выбор оптимальной стратегии

4. ПЛАН ДЕЙСТВИЙ
   - Ключевые этапы реализации
   - Метрики успеха
   - План управления рисками
"""
\`\`\`

### 3. Техническое решение проблем

\`\`\`python
technical_cot = """
Диагностируй и реши техническую проблему:

Проблема: [ОПИСАНИЕ ТЕХНИЧЕСКОЙ ПРОБЛЕМЫ]

1. АНАЛИЗ СИМПТОМОВ
   - Что именно происходит?
   - При каких условиях проявляется?
   - Есть ли паттерн в возникновении?

2. ГИПОТЕЗЫ О ПРИЧИНАХ
   - Возможная причина 1: [анализ вероятности]
   - Возможная причина 2: [анализ вероятности]
   - Возможная причина 3: [анализ вероятности]

3. ПЛАН ДИАГНОСТИКИ
   - Какие тесты нужно провести?
   - В каком порядке?
   - Что каждый тест должен показать?

4. РЕШЕНИЕ
   - Наиболее вероятная причина
   - План исправления
   - Меры предотвращения повторения
"""
\`\`\`

## Оптимизация Chain-of-Thought

### 1. Длина цепочки рассуждений

\`\`\`python
# Слишком короткая цепочка
short_cot = "Решаю: 1) считаю, 2) получаю ответ"

# Оптимальная длина
optimal_cot = """
1. Анализирую исходные данные
2. Определяю необходимые вычисления  
3. Выполняю каждое вычисление с проверкой
4. Проверяю логику решения
5. Формулирую финальный ответ
"""

# Слишком длинная цепочка (может запутать модель)
# Избегайте более 10-15 шагов в одной цепочке
\`\`\`

### 2. Ясность шагов

\`\`\`python
# Неясные шаги
unclear = "1. Думаю об этом 2. Рассматриваю варианты 3. Делаю выбор"

# Четкие шаги
clear = """
1. Определяю критерии оценки вариантов
2. Анализирую каждый вариант по критериям  
3. Сравниваю варианты и выбираю лучший
"""
\`\`\`

### 3. Проверка промежуточных результатов

\`\`\`python
prompt_with_validation = """
Решаю задачу с промежуточными проверками:

1. [Первый шаг]
   Проверка: логично ли это?
   
2. [Второй шаг] 
   Проверка: согласуется ли с предыдущим шагом?
   
3. [Третий шаг]
   Проверка: приводит ли к разумному результату?
"""
\`\`\`

## Измерение эффективности CoT

### Метрики качества:

1. **Логическая связность** — каждый шаг следует из предыдущего
2. **Полнота рассуждения** — учтены все важные аспекты
3. **Точность результата** — правильность финального ответа
4. **Объяснимость** — можно проследить логику

### Сравнение результатов:

\`\`\`python
def compare_cot_effectiveness(task, standard_prompt, cot_prompt):
    """
    Сравнивает эффективность стандартного промпта и CoT
    """
    standard_result = get_gpt_response(standard_prompt + task)
    cot_result = get_gpt_response(cot_prompt + task)
    
    return {
        'standard': {
            'response': standard_result,
            'accuracy': evaluate_accuracy(standard_result),
            'explanation_quality': evaluate_explanation(standard_result)
        },
        'cot': {
            'response': cot_result,
            'accuracy': evaluate_accuracy(cot_result),
            'explanation_quality': evaluate_explanation(cot_result)
        }
    }
\`\`\`

## Заключение

Chain-of-Thought — это мощная техника, которая:

✅ **Повышает точность** сложных рассуждений
✅ **Обеспечивает прозрачность** процесса мышления  
✅ **Улучшает обучение** пользователей
✅ **Снижает галлюцинации** модели

**Ключевые принципы применения:**
1. Используйте для сложных задач, требующих логики
2. Структурируйте шаги четко и последовательно
3. Добавляйте промежуточные проверки
4. Тестируйте на разных типах задач
5. Находите баланс между детальностью и краткостью

CoT особенно эффективен для математических задач, анализа данных, стратегического планирования и любых задач, требующих пошагового мышления.`,
          type: "article",
          order_index: 1,
          duration: 35
        }
      ]
    },
    {
      title: "Function Calling и структурированные ответы",
      description: "Использование функциональных вызовов для получения структурированных данных и интеграции с внешними системами",
      order_index: 4,
      lessons: [
        {
          title: "Function Calling в OpenAI API",
          content: `# Function Calling в OpenAI API

## Что такое Function Calling

**Function Calling** — это возможность GPT моделей вызывать определенные функции и возвращать структурированные ответы в заданном формате. Это мощный инструмент для интеграции ИИ с внешними API, базами данных и бизнес-логикой.

### Основные преимущества

1. **Структурированные ответы** — получение данных в JSON формате
2. **Интеграция с API** — автоматические вызовы внешних сервисов
3. **Валидация данных** — проверка корректности параметров
4. **Безопасность** — контролируемое выполнение действий

## Базовая реализация

### 1. Определение функции

\`\`\`python
import openai
import json

# Определяем схему функции
function_schema = {
    "name": "get_weather",
    "description": "Получить текущую погоду для указанного города",
    "parameters": {
        "type": "object",
        "properties": {
            "city": {
                "type": "string",
                "description": "Название города"
            },
            "units": {
                "type": "string",
                "enum": ["celsius", "fahrenheit"],
                "description": "Единицы измерения температуры"
            }
        },
        "required": ["city"]
    }
}

# Функция для выполнения
def get_weather(city, units="celsius"):
    """Реальная функция для получения погоды"""
    # Здесь был бы вызов API погоды
    return {
        "city": city,
        "temperature": 22 if units == "celsius" else 72,
        "condition": "sunny",
        "units": units
    }
\`\`\`

### 2. Вызов через OpenAI API

\`\`\`python
def chat_with_functions(user_message):
    response = openai.ChatCompletion.create(
        model="gpt-4",
        messages=[
            {"role": "system", "content": "Ты помощник, который может получать информацию о погоде."},
            {"role": "user", "content": user_message}
        ],
        functions=[function_schema],
        function_call="auto"  # Автоматически решает, вызывать ли функцию
    )
    
    message = response.choices[0].message
    
    # Проверяем, была ли вызвана функция
    if message.get("function_call"):
        function_name = message["function_call"]["name"]
        function_args = json.loads(message["function_call"]["arguments"])
        
        # Выполняем функцию
        if function_name == "get_weather":
            function_result = get_weather(**function_args)
            
            # Отправляем результат обратно в GPT
            second_response = openai.ChatCompletion.create(
                model="gpt-4",
                messages=[
                    {"role": "system", "content": "Ты помощник, который может получать информацию о погоде."},
                    {"role": "user", "content": user_message},
                    message,
                    {
                        "role": "function",
                        "name": function_name,
                        "content": json.dumps(function_result)
                    }
                ],
                functions=[function_schema],
                function_call="auto"
            )
            
            return second_response.choices[0].message.content
    else:
        return message.content

# Использование
result = chat_with_functions("Какая погода в Москве?")
print(result)
\`\`\`

## Продвинутые схемы функций

### 1. Функция для работы с базой данных

\`\`\`python
search_users_schema = {
    "name": "search_users",
    "description": "Поиск пользователей в базе данных по различным критериям",
    "parameters": {
        "type": "object",
        "properties": {
            "filters": {
                "type": "object",
                "properties": {
                    "name": {"type": "string", "description": "Имя пользователя"},
                    "email": {"type": "string", "description": "Email пользователя"},
                    "age_min": {"type": "integer", "description": "Минимальный возраст"},
                    "age_max": {"type": "integer", "description": "Максимальный возраст"},
                    "department": {"type": "string", "description": "Отдел компании"},
                    "role": {
                        "type": "string", 
                        "enum": ["admin", "user", "manager"],
                        "description": "Роль пользователя"
                    }
                }
            },
            "sort_by": {
                "type": "string",
                "enum": ["name", "age", "created_at"],
                "description": "Поле для сортировки"
            },
            "limit": {
                "type": "integer",
                "minimum": 1,
                "maximum": 100,
                "description": "Максимальное количество результатов"
            }
        },
        "required": ["filters"]
    }
}

def search_users(filters, sort_by="name", limit=10):
    """Функция поиска пользователей"""
    # Здесь была бы реальная работа с БД
    query = build_database_query(filters, sort_by, limit)
    return execute_query(query)
\`\`\`

### 2. Функция для отправки email

\`\`\`python
send_email_schema = {
    "name": "send_email",
    "description": "Отправка email сообщения",
    "parameters": {
        "type": "object",
        "properties": {
            "recipients": {
                "type": "array",
                "items": {"type": "string", "format": "email"},
                "description": "Список email адресов получателей"
            },
            "subject": {
                "type": "string",
                "maxLength": 200,
                "description": "Тема письма"
            },
            "body": {
                "type": "string",
                "description": "Текст письма"
            },
            "priority": {
                "type": "string",
                "enum": ["low", "normal", "high"],
                "default": "normal",
                "description": "Приоритет письма"
            },
            "attachments": {
                "type": "array",
                "items": {"type": "string"},
                "description": "Пути к файлам вложений"
            }
        },
        "required": ["recipients", "subject", "body"]
    }
}

def send_email(recipients, subject, body, priority="normal", attachments=None):
    """Функция отправки email"""
    email_data = {
        "to": recipients,
        "subject": subject,
        "body": body,
        "priority": priority,
        "attachments": attachments or []
    }
    
    # Здесь был бы реальный код отправки
    return {"status": "sent", "message_id": "12345"}
\`\`\`

### 3. Функция для создания задач

\`\`\`python
create_task_schema = {
    "name": "create_task",
    "description": "Создание новой задачи в системе управления проектами",
    "parameters": {
        "type": "object",
        "properties": {
            "title": {
                "type": "string",
                "maxLength": 100,
                "description": "Название задачи"
            },
            "description": {
                "type": "string",
                "description": "Подробное описание задачи"
            },
            "assignee": {
                "type": "string",
                "description": "Ответственный за задачу (email или ID)"
            },
            "priority": {
                "type": "string",
                "enum": ["low", "medium", "high", "critical"],
                "default": "medium"
            },
            "due_date": {
                "type": "string",
                "format": "date",
                "description": "Дата выполнения в формате YYYY-MM-DD"
            },
            "labels": {
                "type": "array",
                "items": {"type": "string"},
                "description": "Метки для классификации задачи"
            },
            "estimated_hours": {
                "type": "number",
                "minimum": 0.5,
                "maximum": 200,
                "description": "Оценка времени выполнения в часах"
            }
        },
        "required": ["title", "assignee"]
    }
}
\`\`\`

## Обработка множественных функций

### Система с несколькими функциями

\`\`\`python
class AIAssistant:
    def __init__(self):
        self.functions = {
            "get_weather": {
                "schema": get_weather_schema,
                "handler": self.get_weather
            },
            "search_users": {
                "schema": search_users_schema, 
                "handler": self.search_users
            },
            "send_email": {
                "schema": send_email_schema,
                "handler": self.send_email
            },
            "create_task": {
                "schema": create_task_schema,
                "handler": self.create_task
            }
        }
    
    def chat(self, user_message, conversation_history=None):
        """Основной метод для общения с ИИ"""
        messages = conversation_history or []
        messages.append({"role": "user", "content": user_message})
        
        # Получаем схемы всех доступных функций
        function_schemas = [func["schema"] for func in self.functions.values()]
        
        response = openai.ChatCompletion.create(
            model="gpt-4",
            messages=messages,
            functions=function_schemas,
            function_call="auto"
        )
        
        return self.process_response(response, messages)
    
    def process_response(self, response, messages):
        """Обработка ответа от OpenAI"""
        message = response.choices[0].message
        messages.append(message)
        
        if message.get("function_call"):
            # Выполняем вызванную функцию
            function_name = message["function_call"]["name"]
            function_args = json.loads(message["function_call"]["arguments"])
            
            if function_name in self.functions:
                try:
                    # Выполняем функцию
                    result = self.functions[function_name]["handler"](**function_args)
                    
                    # Добавляем результат в историю
                    messages.append({
                        "role": "function",
                        "name": function_name,
                        "content": json.dumps(result)
                    })
                    
                    # Получаем финальный ответ
                    final_response = openai.ChatCompletion.create(
                        model="gpt-4",
                        messages=messages,
                        functions=[func["schema"] for func in self.functions.values()],
                        function_call="auto"
                    )
                    
                    return self.process_response(final_response, messages)
                    
                except Exception as e:
                    error_message = f"Ошибка выполнения функции {function_name}: {str(e)}"
                    messages.append({
                        "role": "function",
                        "name": function_name,
                        "content": json.dumps({"error": error_message})
                    })
                    
                    # Сообщаем об ошибке пользователю
                    return f"Извините, произошла ошибка: {error_message}"
        
        return message.content
    
    # Методы-обработчики функций
    def get_weather(self, city, units="celsius"):
        # Реализация получения погоды
        pass
    
    def search_users(self, filters, sort_by="name", limit=10):
        # Реализация поиска пользователей
        pass
    
    def send_email(self, recipients, subject, body, priority="normal", attachments=None):
        # Реализация отправки email
        pass
    
    def create_task(self, title, assignee, description=None, priority="medium", due_date=None, labels=None, estimated_hours=None):
        # Реализация создания задачи
        pass
\`\`\`

## Валидация и обработка ошибок

### 1. Валидация входных параметров

\`\`\`python
from jsonschema import validate, ValidationError

def validate_function_params(params, schema):
    """Валидация параметров функции"""
    try:
        validate(instance=params, schema=schema["parameters"])
        return True, None
    except ValidationError as e:
        return False, str(e)

def safe_function_call(function_name, params, available_functions):
    """Безопасный вызов функции с валидацией"""
    if function_name not in available_functions:
        return {"error": f"Функция {function_name} не найдена"}
    
    function_info = available_functions[function_name]
    
    # Валидируем параметры
    is_valid, error_message = validate_function_params(params, function_info["schema"])
    if not is_valid:
        return {"error": f"Неверные параметры: {error_message}"}
    
    try:
        # Выполняем функцию
        result = function_info["handler"](**params)
        return {"success": True, "data": result}
    except Exception as e:
        return {"error": f"Ошибка выполнения: {str(e)}"}
\`\`\`

### 2. Обработка timeout и ретраев

\`\`\`python
import time
from functools import wraps

def with_timeout(timeout_seconds=30):
    """Декоратор для ограничения времени выполнения функции"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            import signal
            
            def timeout_handler(signum, frame):
                raise TimeoutError(f"Функция {func.__name__} превысила лимит времени {timeout_seconds}с")
            
            # Устанавливаем таймер
            signal.signal(signal.SIGALRM, timeout_handler)
            signal.alarm(timeout_seconds)
            
            try:
                result = func(*args, **kwargs)
                signal.alarm(0)  # Отменяем таймер
                return result
            except TimeoutError:
                raise
            finally:
                signal.alarm(0)
        
        return wrapper
    return decorator

def with_retry(max_attempts=3, delay=1):
    """Декоратор для повторных попыток выполнения функции"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            for attempt in range(max_attempts):
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    if attempt == max_attempts - 1:
                        raise e
                    time.sleep(delay * (2 ** attempt))  # Экспоненциальная задержка
            
        return wrapper
    return decorator

# Применение декораторов
@with_timeout(10)
@with_retry(max_attempts=3)
def external_api_call(url, params):
    """Вызов внешнего API с таймаутом и ретраями"""
    import requests
    response = requests.get(url, params=params, timeout=5)
    response.raise_for_status()
    return response.json()
\`\`\`

## Продвинутые паттерны

### 1. Условное выполнение функций

\`\`\`python
conditional_action_schema = {
    "name": "conditional_action",
    "description": "Выполнение действия при соблюдении условий",
    "parameters": {
        "type": "object",
        "properties": {
            "condition": {
                "type": "object",
                "properties": {
                    "field": {"type": "string"},
                    "operator": {"type": "string", "enum": ["equals", "greater", "less", "contains"]},
                    "value": {"type": ["string", "number", "boolean"]}
                }
            },
            "action_if_true": {
                "type": "object",
                "properties": {
                    "function": {"type": "string"},
                    "parameters": {"type": "object"}
                }
            },
            "action_if_false": {
                "type": "object", 
                "properties": {
                    "function": {"type": "string"},
                    "parameters": {"type": "object"}
                }
            }
        },
        "required": ["condition", "action_if_true"]
    }
}
\`\`\`

### 2. Batch-операции

\`\`\`python
batch_operation_schema = {
    "name": "batch_operation",
    "description": "Выполнение операции над множеством объектов",
    "parameters": {
        "type": "object",
        "properties": {
            "operation": {
                "type": "string",
                "enum": ["create", "update", "delete"],
                "description": "Тип операции"
            },
            "objects": {
                "type": "array",
                "items": {"type": "object"},
                "description": "Массив объектов для обработки"
            },
            "batch_size": {
                "type": "integer",
                "minimum": 1,
                "maximum": 100,
                "default": 10,
                "description": "Размер пакета для обработки"
            }
        },
        "required": ["operation", "objects"]
    }
}

def batch_operation(operation, objects, batch_size=10):
    """Выполнение пакетных операций"""
    results = []
    
    # Разбиваем на пакеты
    for i in range(0, len(objects), batch_size):
        batch = objects[i:i + batch_size]
        
        try:
            if operation == "create":
                batch_result = create_objects(batch)
            elif operation == "update":
                batch_result = update_objects(batch)
            elif operation == "delete":
                batch_result = delete_objects(batch)
            
            results.extend(batch_result)
            
        except Exception as e:
            # Логируем ошибку пакета, но продолжаем
            results.append({
                "batch_index": i // batch_size,
                "error": str(e),
                "objects_count": len(batch)
            })
    
    return {
        "total_processed": len(objects),
        "successful": len([r for r in results if "error" not in r]),
        "failed": len([r for r in results if "error" in r]),
        "results": results
    }
\`\`\`

## Мониторинг и логирование

### 1. Логирование вызовов функций

\`\`\`python
import logging
from datetime import datetime

def log_function_call(func):
    """Декоратор для логирования вызовов функций"""
    @wraps(func)
    def wrapper(*args, **kwargs):
        start_time = datetime.now()
        logger = logging.getLogger(f"functions.{func.__name__}")
        
        try:
            logger.info(f"Вызов функции {func.__name__} с параметрами: args={args}, kwargs={kwargs}")
            result = func(*args, **kwargs)
            
            duration = (datetime.now() - start_time).total_seconds()
            logger.info(f"Функция {func.__name__} выполнена успешно за {duration:.2f}с")
            
            return result
            
        except Exception as e:
            duration = (datetime.now() - start_time).total_seconds()
            logger.error(f"Ошибка в функции {func.__name__} после {duration:.2f}с: {str(e)}")
            raise
    
    return wrapper
\`\`\`

### 2. Метрики производительности

\`\`\`python
class FunctionMetrics:
    def __init__(self):
        self.call_counts = {}
        self.execution_times = {}
        self.error_counts = {}
    
    def record_call(self, function_name, execution_time, success=True):
        """Записываем метрики вызова функции"""
        if function_name not in self.call_counts:
            self.call_counts[function_name] = 0
            self.execution_times[function_name] = []
            self.error_counts[function_name] = 0
        
        self.call_counts[function_name] += 1
        self.execution_times[function_name].append(execution_time)
        
        if not success:
            self.error_counts[function_name] += 1
    
    def get_stats(self, function_name=None):
        """Получение статистики по функциям"""
        if function_name:
            return self._get_function_stats(function_name)
        
        stats = {}
        for func_name in self.call_counts:
            stats[func_name] = self._get_function_stats(func_name)
        
        return stats
    
    def _get_function_stats(self, function_name):
        """Статистика по конкретной функции"""
        if function_name not in self.call_counts:
            return None
        
        times = self.execution_times[function_name]
        
        return {
            "total_calls": self.call_counts[function_name],
            "total_errors": self.error_counts[function_name],
            "error_rate": self.error_counts[function_name] / self.call_counts[function_name],
            "avg_execution_time": sum(times) / len(times),
            "min_execution_time": min(times),
            "max_execution_time": max(times)
        }

# Глобальный объект метрик
function_metrics = FunctionMetrics()
\`\`\`

## Заключение

Function Calling открывает огромные возможности для интеграции GPT с реальными системами:

✅ **Структурированная интеграция** с внешними API
✅ **Валидация данных** и типобезопасность
✅ **Масштабируемая архитектура** для сложных систем
✅ **Контролируемое выполнение** действий

**Ключевые принципы:**
1. Четко определяйте схемы функций
2. Всегда валидируйте входные параметры
3. Обрабатывайте ошибки и таймауты
4. Логируйте вызовы для отладки
5. Тестируйте функции изолированно
6. Следите за производительностью и безопасностью

Function Calling превращает GPT из простого чат-бота в мощный инструмент автоматизации и интеграции.`,
          type: "article",
          order_index: 1,
          duration: 40
        }
      ]
    },
    {
      title: "Создание чат-бота и безопасность",
      description: "Практическое создание собственного чат-бота на основе промптов и обеспечение безопасности взаимодействия с ИИ",
      order_index: 5,
      lessons: [
        {
          title: "Архитектура и реализация чат-бота",
          content: `# Архитектура и реализация чат-бота

## Архитектура современного чат-бота

Создание профессионального чат-бота требует продуманной архитектуры, которая обеспечивает масштабируемость, безопасность и качественное пользовательское взаимодействие.

### Компоненты системы

\`\`\`
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│   Пользователь  │ ←→ │  Веб-интерфейс  │ ←→ │  API Gateway   │
└─────────────────┘    └──────────────────┘    └─────────────────┘
                                                        │
                       ┌─────────────────────────────────┼─────────────────────────────────┐
                       │                                 │                                 │
                ┌──────▼───────┐              ┌─────────▼────────┐              ┌─────────▼────────┐
                │ Chat Manager │              │ Context Manager  │              │ Safety Filter    │
                └──────┬───────┘              └─────────┬────────┘              └─────────┬────────┘
                       │                                 │                                 │
                ┌──────▼───────┐              ┌─────────▼────────┐              ┌─────────▼────────┐
                │ OpenAI API   │              │ Session Storage  │              │ Content Moderation│
                └──────────────┘              └──────────────────┘              └──────────────────┘
\`\`\`

## Базовая реализация

### 1. Основной класс чат-бота

\`\`\`python
import openai
import json
import uuid
from datetime import datetime, timedelta
from typing import Dict, List, Optional
import asyncio
import aioredis
from dataclasses import dataclass

@dataclass
class ChatMessage:
    """Структура сообщения в чате"""
    id: str
    user_id: str
    content: str
    role: str  # 'user', 'assistant', 'system'
    timestamp: datetime
    metadata: Optional[Dict] = None

@dataclass
class ChatSession:
    """Структура сессии чата"""
    session_id: str
    user_id: str
    created_at: datetime
    last_activity: datetime
    context: Dict
    message_count: int
    
class AdvancedChatBot:
    def __init__(self, openai_api_key: str, redis_url: str = None):
        """Инициализация чат-бота"""
        openai.api_key = openai_api_key
        self.redis = None
        if redis_url:
            self.redis = aioredis.from_url(redis_url)
        
        # Конфигурация модели
        self.model_config = {
            "model": "gpt-4",
            "temperature": 0.7,
            "max_tokens": 2000,
            "top_p": 0.9
        }
        
        # Системный промпт по умолчанию
        self.default_system_prompt = """
        Ты умный и дружелюбный ИИ-ассистент. Твоя задача - помогать пользователям с их вопросами и задачами.
        
        Принципы работы:
        - Будь полезным и информативным
        - Отвечай четко и по существу
        - Если не знаешь ответа, честно признайся в этом
        - Соблюдай этические принципы
        - Не выполняй вредоносные или незаконные запросы
        """
        
        # Менеджер контекста
        self.context_manager = ContextManager(self.redis)
        
        # Фильтр безопасности
        self.safety_filter = SafetyFilter()
    
    async def create_session(self, user_id: str, context: Dict = None) -> str:
        """Создание новой сессии чата"""
        session_id = str(uuid.uuid4())
        session = ChatSession(
            session_id=session_id,
            user_id=user_id,
            created_at=datetime.now(),
            last_activity=datetime.now(),
            context=context or {},
            message_count=0
        )
        
        await self.context_manager.save_session(session)
        return session_id
    
    async def send_message(self, session_id: str, user_message: str, context_update: Dict = None) -> Dict:
        """Отправка сообщения в чат"""
        try:
            # Получаем сессию
            session = await self.context_manager.get_session(session_id)
            if not session:
                return {"error": "Сессия не найдена"}
            
            # Проверяем безопасность входящего сообщения
            safety_check = await self.safety_filter.check_input(user_message)
            if not safety_check["safe"]:
                return {
                    "error": "Сообщение не прошло проверку безопасности",
                    "reason": safety_check["reason"]
                }
            
            # Обновляем контекст сессии
            if context_update:
                session.context.update(context_update)
            
            # Формируем историю сообщений
            messages = await self.context_manager.get_conversation_history(session_id)
            
            # Добавляем текущее сообщение пользователя
            user_msg = ChatMessage(
                id=str(uuid.uuid4()),
                user_id=session.user_id,
                content=user_message,
                role="user",
                timestamp=datetime.now()
            )
            
            # Сохраняем сообщение пользователя
            await self.context_manager.save_message(session_id, user_msg)
            
            # Формируем запрос к OpenAI
            openai_messages = self._prepare_openai_messages(messages, user_msg, session.context)
            
            # Получаем ответ от GPT
            response = await self._get_openai_response(openai_messages)
            
            # Проверяем безопасность ответа
            output_safety = await self.safety_filter.check_output(response)
            if not output_safety["safe"]:
                response = "Извините, я не могу предоставить этот ответ из соображений безопасности."
            
            # Создаем сообщение ассистента
            assistant_msg = ChatMessage(
                id=str(uuid.uuid4()),
                user_id=session.user_id,
                content=response,
                role="assistant",
                timestamp=datetime.now()
            )
            
            # Сохраняем ответ
            await self.context_manager.save_message(session_id, assistant_msg)
            
            # Обновляем активность сессии
            await self.context_manager.update_session_activity(session_id)
            
            return {
                "success": True,
                "response": response,
                "message_id": assistant_msg.id,
                "session_info": {
                    "message_count": session.message_count + 2,
                    "last_activity": datetime.now().isoformat()
                }
            }
            
        except Exception as e:
            return {"error": f"Ошибка обработки сообщения: {str(e)}"}
    
    def _prepare_openai_messages(self, history: List[ChatMessage], current_msg: ChatMessage, context: Dict) -> List[Dict]:
        """Подготовка сообщений для OpenAI API"""
        messages = []
        
        # Добавляем системный промпт с контекстом
        system_prompt = self._build_system_prompt(context)
        messages.append({"role": "system", "content": system_prompt})
        
        # Добавляем историю (последние N сообщений)
        max_history = 20  # Ограничиваем историю
        recent_history = history[-max_history:] if len(history) > max_history else history
        
        for msg in recent_history:
            messages.append({
                "role": msg.role,
                "content": msg.content
            })
        
        # Добавляем текущее сообщение
        messages.append({
            "role": current_msg.role,
            "content": current_msg.content
        })
        
        return messages
    
    def _build_system_prompt(self, context: Dict) -> str:
        """Построение системного промпта с учетом контекста"""
        prompt = self.default_system_prompt
        
        # Добавляем персонализацию
        if context.get("user_name"):
            prompt += f"\\n\\nТы общаешься с пользователем по имени {context['user_name']}."
        
        if context.get("user_preferences"):
            prefs = context["user_preferences"]
            prompt += f"\\n\\nПредпочтения пользователя: {json.dumps(prefs, ensure_ascii=False)}"
        
        if context.get("domain_expertise"):
            prompt += f"\\n\\nОбласть экспертизы для этой сессии: {context['domain_expertise']}"
        
        if context.get("conversation_style"):
            prompt += f"\\n\\nСтиль общения: {context['conversation_style']}"
        
        return prompt
    
    async def _get_openai_response(self, messages: List[Dict]) -> str:
        """Получение ответа от OpenAI API"""
        try:
            response = await openai.ChatCompletion.acreate(
                messages=messages,
                **self.model_config
            )
            
            return response.choices[0].message.content
            
        except Exception as e:
            raise Exception(f"Ошибка OpenAI API: {str(e)}")
\`\`\`

### 2. Менеджер контекста

\`\`\`python
class ContextManager:
    """Управление контекстом и историей разговоров"""
    
    def __init__(self, redis_client=None):
        self.redis = redis_client
        self.session_ttl = 3600 * 24  # 24 часа
        self.message_ttl = 3600 * 24 * 7  # 7 дней
    
    async def save_session(self, session: ChatSession):
        """Сохранение сессии"""
        if self.redis:
            session_key = f"session:{session.session_id}"
            session_data = {
                "user_id": session.user_id,
                "created_at": session.created_at.isoformat(),
                "last_activity": session.last_activity.isoformat(),
                "context": json.dumps(session.context),
                "message_count": session.message_count
            }
            
            await self.redis.hmset(session_key, session_data)
            await self.redis.expire(session_key, self.session_ttl)
    
    async def get_session(self, session_id: str) -> Optional[ChatSession]:
        """Получение сессии"""
        if not self.redis:
            return None
        
        session_key = f"session:{session_id}"
        session_data = await self.redis.hgetall(session_key)
        
        if not session_data:
            return None
        
        return ChatSession(
            session_id=session_id,
            user_id=session_data[b"user_id"].decode(),
            created_at=datetime.fromisoformat(session_data[b"created_at"].decode()),
            last_activity=datetime.fromisoformat(session_data[b"last_activity"].decode()),
            context=json.loads(session_data[b"context"].decode()),
            message_count=int(session_data[b"message_count"])
        )
    
    async def save_message(self, session_id: str, message: ChatMessage):
        """Сохранение сообщения"""
        if self.redis:
            message_key = f"messages:{session_id}:{message.id}"
            message_data = {
                "user_id": message.user_id,
                "content": message.content,
                "role": message.role,
                "timestamp": message.timestamp.isoformat(),
                "metadata": json.dumps(message.metadata or {})
            }
            
            await self.redis.hmset(message_key, message_data)
            await self.redis.expire(message_key, self.message_ttl)
            
            # Добавляем в список сообщений сессии
            session_messages_key = f"session_messages:{session_id}"
            await self.redis.zadd(session_messages_key, {message.id: message.timestamp.timestamp()})
            await self.redis.expire(session_messages_key, self.message_ttl)
    
    async def get_conversation_history(self, session_id: str, limit: int = 50) -> List[ChatMessage]:
        """Получение истории разговора"""
        if not self.redis:
            return []
        
        session_messages_key = f"session_messages:{session_id}"
        message_ids = await self.redis.zrange(session_messages_key, -limit, -1)
        
        messages = []
        for message_id in message_ids:
            message_key = f"messages:{session_id}:{message_id.decode()}"
            message_data = await self.redis.hgetall(message_key)
            
            if message_data:
                message = ChatMessage(
                    id=message_id.decode(),
                    user_id=message_data[b"user_id"].decode(),
                    content=message_data[b"content"].decode(),
                    role=message_data[b"role"].decode(),
                    timestamp=datetime.fromisoformat(message_data[b"timestamp"].decode()),
                    metadata=json.loads(message_data[b"metadata"].decode())
                )
                messages.append(message)
        
        return messages
    
    async def update_session_activity(self, session_id: str):
        """Обновление времени последней активности"""
        if self.redis:
            session_key = f"session:{session_id}"
            await self.redis.hset(session_key, "last_activity", datetime.now().isoformat())
\`\`\`

### 3. Фильтр безопасности

\`\`\`python
import re
from typing import Dict, List

class SafetyFilter:
    """Фильтр безопасности для входящих и исходящих сообщений"""
    
    def __init__(self):
        # Запрещенные паттерны
        self.forbidden_patterns = [
            r"\\b(?:пароль|password)\\s*[:=]\\s*\\w+",  # Пароли
            r"\\b\\d{4}\\s*\\d{4}\\s*\\d{4}\\s*\\d{4}\\b",  # Номера карт
            r"\\b\\d{3}-\\d{2}-\\d{4}\\b",  # SSN
            r"\\bmurderer?\\b|\\bkill\\b|\\bdie\\b",  # Угрозы (базовые)
        ]
        
        self.compiled_patterns = [re.compile(pattern, re.IGNORECASE) for pattern in self.forbidden_patterns]
        
        # Список запрещенных тем
        self.forbidden_topics = [
            "explicit_violence",
            "illegal_activities", 
            "personal_data_extraction",
            "malware_creation",
            "discrimination"
        ]
    
    async def check_input(self, message: str) -> Dict:
        """Проверка входящего сообщения"""
        # Проверка на запрещенные паттерны
        for pattern in self.compiled_patterns:
            if pattern.search(message):
                return {
                    "safe": False,
                    "reason": "Обнаружен потенциально опасный контент",
                    "category": "pattern_match"
                }
        
        # Проверка длины сообщения
        if len(message) > 4000:
            return {
                "safe": False,
                "reason": "Сообщение слишком длинное",
                "category": "length_limit"
            }
        
        # Проверка на чрезмерное повторение
        if self._check_repetition(message):
            return {
                "safe": False,
                "reason": "Обнаружено чрезмерное повторение",
                "category": "spam_detection"
            }
        
        # Можно добавить вызов модерационного API
        # moderation_result = await self._openai_moderation(message)
        
        return {"safe": True}
    
    async def check_output(self, message: str) -> Dict:
        """Проверка исходящего сообщения"""
        # Проверка на утечку данных
        if self._check_data_leakage(message):
            return {
                "safe": False,
                "reason": "Потенциальная утечка данных",
                "category": "data_leakage"
            }
        
        # Проверка на модерацию через OpenAI
        try:
            moderation_result = await self._openai_moderation(message)
            if moderation_result["flagged"]:
                return {
                    "safe": False,
                    "reason": "Контент не прошел модерацию",
                    "category": "content_moderation",
                    "details": moderation_result["categories"]
                }
        except Exception as e:
            # Если модерация недоступна, применяем консервативный подход
            pass
        
        return {"safe": True}
    
    def _check_repetition(self, message: str) -> bool:
        """Проверка на чрезмерное повторение символов или слов"""
        # Проверка повторения символов
        if re.search(r"(.)\\1{10,}", message):
            return True
        
        # Проверка повторения слов
        words = message.split()
        if len(words) > 5:
            word_counts = {}
            for word in words:
                word_counts[word] = word_counts.get(word, 0) + 1
                if word_counts[word] > len(words) * 0.3:  # Более 30% повторений
                    return True
        
        return False
    
    def _check_data_leakage(self, message: str) -> bool:
        """Проверка на потенциальную утечку данных"""
        # Поиск структурированных данных
        if re.search(r"\\{.*\\}", message) and len(message) > 500:
            return True
        
        # Поиск SQL-подобных структур
        if re.search(r"SELECT.*FROM|INSERT.*INTO|UPDATE.*SET", message, re.IGNORECASE):
            return True
        
        return False
    
    async def _openai_moderation(self, text: str) -> Dict:
        """Модерация через OpenAI API"""
        try:
            response = await openai.Moderation.acreate(input=text)
            return response["results"][0]
        except Exception as e:
            # В случае ошибки возвращаем безопасный результат
            return {"flagged": False, "categories": {}}
\`\`\`

## Веб-интерфейс

### 1. FastAPI backend

\`\`\`python
from fastapi import FastAPI, HTTPException, Depends
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import Optional

app = FastAPI(title="Advanced ChatBot API")

# CORS настройки
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # В продакшене указать конкретные домены
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Инициализация чат-бота
chatbot = AdvancedChatBot(
    openai_api_key="your-openai-api-key",
    redis_url="redis://localhost:6379"
)

class ChatRequest(BaseModel):
    session_id: Optional[str] = None
    message: str
    context: Optional[Dict] = None

class CreateSessionRequest(BaseModel):
    user_id: str
    context: Optional[Dict] = None

@app.post("/api/chat/session")
async def create_session(request: CreateSessionRequest):
    """Создание новой сессии чата"""
    try:
        session_id = await chatbot.create_session(
            user_id=request.user_id,
            context=request.context
        )
        
        return {
            "success": True,
            "session_id": session_id,
            "message": "Сессия создана успешно"
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/chat/message")
async def send_message(request: ChatRequest):
    """Отправка сообщения в чат"""
    try:
        if not request.session_id:
            raise HTTPException(status_code=400, detail="session_id обязателен")
        
        result = await chatbot.send_message(
            session_id=request.session_id,
            user_message=request.message,
            context_update=request.context
        )
        
        if "error" in result:
            raise HTTPException(status_code=400, detail=result["error"])
        
        return result
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/chat/history/{session_id}")
async def get_chat_history(session_id: str, limit: int = 50):
    """Получение истории чата"""
    try:
        history = await chatbot.context_manager.get_conversation_history(
            session_id=session_id,
            limit=limit
        )
        
        return {
            "success": True,
            "messages": [
                {
                    "id": msg.id,
                    "content": msg.content,
                    "role": msg.role,
                    "timestamp": msg.timestamp.isoformat()
                }
                for msg in history
            ]
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
\`\`\`

### 2. React frontend

\`\`\`typescript
import React, { useState, useEffect, useRef } from 'react';
import axios from 'axios';

interface Message {
  id: string;
  content: string;
  role: 'user' | 'assistant';
  timestamp: string;
}

interface ChatSession {
  sessionId: string;
  messages: Message[];
}

const ChatBot: React.FC = () => {
  const [session, setSession] = useState<ChatSession | null>(null);
  const [inputMessage, setInputMessage] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const messagesEndRef = useRef<HTMLDivElement>(null);

  const API_BASE = 'http://localhost:8000/api';

  useEffect(() => {
    createNewSession();
  }, []);

  useEffect(() => {
    scrollToBottom();
  }, [session?.messages]);

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  };

  const createNewSession = async () => {
    try {
      const response = await axios.post(\`\${API_BASE}/chat/session\`, {
        user_id: 'user_' + Date.now(),
        context: {
          user_name: 'Пользователь',
          conversation_style: 'friendly'
        }
      });

      setSession({
        sessionId: response.data.session_id,
        messages: []
      });
    } catch (error) {
      console.error('Ошибка создания сессии:', error);
    }
  };

  const sendMessage = async () => {
    if (!inputMessage.trim() || !session || isLoading) return;

    const userMessage: Message = {
      id: Date.now().toString(),
      content: inputMessage,
      role: 'user',
      timestamp: new Date().toISOString()
    };

    // Добавляем сообщение пользователя
    setSession(prev => prev ? {
      ...prev,
      messages: [...prev.messages, userMessage]
    } : null);

    setInputMessage('');
    setIsLoading(true);

    try {
      const response = await axios.post(\`\${API_BASE}/chat/message\`, {
        session_id: session.sessionId,
        message: inputMessage
      });

      const assistantMessage: Message = {
        id: response.data.message_id,
        content: response.data.response,
        role: 'assistant',
        timestamp: new Date().toISOString()
      };

      setSession(prev => prev ? {
        ...prev,
        messages: [...prev.messages, assistantMessage]
      } : null);

    } catch (error) {
      console.error('Ошибка отправки сообщения:', error);
      
      const errorMessage: Message = {
        id: Date.now().toString(),
        content: 'Извините, произошла ошибка при отправке сообщения.',
        role: 'assistant',
        timestamp: new Date().toISOString()
      };

      setSession(prev => prev ? {
        ...prev,
        messages: [...prev.messages, errorMessage]
      } : null);
    } finally {
      setIsLoading(false);
    }
  };

  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      sendMessage();
    }
  };

  return (
    <div className="flex flex-col h-screen max-w-4xl mx-auto bg-white shadow-lg">
      {/* Header */}
      <div className="bg-blue-600 text-white p-4 flex justify-between items-center">
        <h1 className="text-xl font-bold">AI Ассистент</h1>
        <button
          onClick={createNewSession}
          className="bg-blue-500 hover:bg-blue-400 px-3 py-1 rounded text-sm"
        >
          Новый чат
        </button>
      </div>

      {/* Messages */}
      <div className="flex-1 overflow-y-auto p-4 space-y-4">
        {session?.messages.map((message) => (
          <div
            key={message.id}
            className={\`flex \${message.role === 'user' ? 'justify-end' : 'justify-start'}\`}
          >
            <div
              className={\`max-w-[70%] p-3 rounded-lg \${
                message.role === 'user'
                  ? 'bg-blue-600 text-white'
                  : 'bg-gray-100 text-gray-800'
              }\`}
            >
              <p className="whitespace-pre-wrap">{message.content}</p>
              <span className="text-xs opacity-70 mt-1 block">
                {new Date(message.timestamp).toLocaleTimeString()}
              </span>
            </div>
          </div>
        ))}
        
        {isLoading && (
          <div className="flex justify-start">
            <div className="bg-gray-100 p-3 rounded-lg">
              <div className="flex space-x-1">
                <div className="w-2 h-2 bg-gray-400 rounded-full animate-bounce"></div>
                <div className="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style={{animationDelay: '0.1s'}}></div>
                <div className="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style={{animationDelay: '0.2s'}}></div>
              </div>
            </div>
          </div>
        )}
        
        <div ref={messagesEndRef} />
      </div>

      {/* Input */}
      <div className="border-t p-4">
        <div className="flex space-x-2">
          <textarea
            value={inputMessage}
            onChange={(e) => setInputMessage(e.target.value)}
            onKeyPress={handleKeyPress}
            placeholder="Введите ваше сообщение..."
            className="flex-1 p-2 border border-gray-300 rounded-lg resize-none focus:outline-none focus:ring-2 focus:ring-blue-500"
            rows={1}
            disabled={isLoading}
          />
          <button
            onClick={sendMessage}
            disabled={isLoading || !inputMessage.trim()}
            className="bg-blue-600 text-white px-6 py-2 rounded-lg hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed"
          >
            Отправить
          </button>
        </div>
      </div>
    </div>
  );
};

export default ChatBot;
\`\`\`

## Развертывание и мониторинг

### 1. Docker конфигурация

\`\`\`dockerfile
# Dockerfile
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

EXPOSE 8000

CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
\`\`\`

\`\`\`yaml
# docker-compose.yml
version: '3.8'

services:
  chatbot-api:
    build: .
    ports:
      - "8000:8000"
    environment:
      - OPENAI_API_KEY=${OPENAI_API_KEY}
      - REDIS_URL=redis://redis:6379
    depends_on:
      - redis
    volumes:
      - ./logs:/app/logs

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./frontend/build:/usr/share/nginx/html
    depends_on:
      - chatbot-api

volumes:
  redis_data:
\`\`\`

### 2. Мониторинг и логирование

\`\`\`python
import logging
from datetime import datetime
import json

class ChatBotLogger:
    def __init__(self, log_level=logging.INFO):
        self.logger = logging.getLogger('chatbot')
        self.logger.setLevel(log_level)
        
        # Форматтер для логов
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        
        # Файловый хендлер
        file_handler = logging.FileHandler('chatbot.log')
        file_handler.setFormatter(formatter)
        self.logger.addHandler(file_handler)
        
        # Консольный хендлер
        console_handler = logging.StreamHandler()
        console_handler.setFormatter(formatter)
        self.logger.addHandler(console_handler)
    
    def log_conversation(self, session_id: str, user_message: str, bot_response: str, processing_time: float):
        """Логирование разговора"""
        log_data = {
            "session_id": session_id,
            "timestamp": datetime.now().isoformat(),
            "user_message": user_message,
            "bot_response": bot_response,
            "processing_time": processing_time,
            "type": "conversation"
        }
        
        self.logger.info(f"CONVERSATION: {json.dumps(log_data, ensure_ascii=False)}")
    
    def log_error(self, session_id: str, error: Exception, context: Dict):
        """Логирование ошибок"""
        log_data = {
            "session_id": session_id,
            "timestamp": datetime.now().isoformat(),
            "error": str(error),
            "error_type": type(error).__name__,
            "context": context,
            "type": "error"
        }
        
        self.logger.error(f"ERROR: {json.dumps(log_data, ensure_ascii=False)}")
    
    def log_safety_violation(self, session_id: str, message: str, violation_type: str):
        """Логирование нарушений безопасности"""
        log_data = {
            "session_id": session_id,
            "timestamp": datetime.now().isoformat(),
            "message": message,
            "violation_type": violation_type,
            "type": "safety_violation"
        }
        
        self.logger.warning(f"SAFETY: {json.dumps(log_data, ensure_ascii=False)}")

# Интеграция логирования в чат-бота
chatbot_logger = ChatBotLogger()
\`\`\`

## Заключение

Создание профессионального чат-бота требует комплексного подхода:

✅ **Архитектура** — модульная и масштабируемая
✅ **Безопасность** — фильтрация входа и выхода
✅ **Контекст** — управление сессиями и историей
✅ **Производительность** — асинхронность и кэширование
✅ **Мониторинг** — логирование и метрики

**Ключевые принципы:**
1. Безопасность превыше всего
2. Качественное управление контекстом
3. Масштабируемая архитектура
4. Comprehensive мониторинг
5. Graceful error handling

Этот подход позволяет создать чат-бота уровня production, готового к реальному использованию.`,
          type: "article",
          order_index: 1,
          duration: 45
        }
      ]
    }
  ]
};

// Функция создания курса
async function createPromptEngineeringCourse() {
  try {
    console.log('🚀 Создание полноценного курса "Prompt-инжиниринг для GPT-моделей"...');
    
    // Сначала очищаем существующие модули и уроки курса
    await db.delete(lessons).where(eq(lessons.course_id, 3));
    await db.delete(courseModules).where(eq(courseModules.course_id, 3));
    
    console.log('✅ Очистка существующего контента завершена');
    
    // Создаем модули и уроки
    for (const moduleData of courseContent.modules) {
      // Создаем модуль
      const [module] = await db.insert(courseModules).values({
        course_id: 3,
        title: moduleData.title,
        description: moduleData.description,
        order_index: moduleData.order_index,
        created_at: new Date(),
        updated_at: new Date()
      }).returning();
      
      console.log(`📚 Создан модуль: ${module.title}`);
      
      // Создаем уроки для модуля
      for (const lessonData of moduleData.lessons) {
        const [lesson] = await db.insert(lessons).values({
          course_id: 3,
          module_id: module.id,
          title: lessonData.title,
          content: lessonData.content,
          type: lessonData.type,
          order_index: lessonData.order_index,
          estimated_duration: lessonData.duration,
          created_at: new Date(),
          updated_at: new Date()
        }).returning();
        
        console.log(`  📖 Создан урок: ${lesson.title} (${lessonData.duration} мин)`);
        
        // Создаем практические задания для каждого урока
        const assignments = [
          {
            title: `Практическое задание: ${lessonData.title}`,
            description: `Практическое применение знаний из урока "${lessonData.title}"`,
            type: 'practical',
            difficulty: 2,
            estimatedTime: Math.ceil(lessonData.duration * 0.5), // 50% от времени урока
            maxAttempts: 3
          },
          {
            title: `Тест: ${lessonData.title}`,
            description: `Проверка знаний по теме "${lessonData.title}"`,
            type: 'quiz',
            difficulty: 1,
            estimatedTime: 10,
            maxAttempts: 2
          }
        ];
        
        for (const assignmentData of assignments) {
          await db.insert(assignments).values({
            lesson_id: lesson.id,
            title: assignmentData.title,
            description: assignmentData.description,
            type: assignmentData.type,
            difficulty: assignmentData.difficulty,
            estimated_time: assignmentData.estimatedTime,
            max_attempts: assignmentData.maxAttempts,
            created_at: new Date(),
            updated_at: new Date()
          });
        }
      }
    }
    
    // Обновляем информацию о курсе
    await db.update(courses)
      .set({
        description: "Полноценный профессиональный курс по промпт-инжинирингу с практическими примерами, кодом и реальными проектами. Изучите создание эффективных промптов, управление контекстом, Chain-of-Thought, Function Calling и создание собственных чат-ботов.",
        updated_at: new Date(),
        modules: 5,
        estimated_duration: 360 // 6 часов
      })
      .where(eq(courses.id, 3));
    
    console.log('🎉 Курс "Prompt-инжиниринг для GPT-моделей" успешно создан!');
    console.log('📊 Статистика:');
    console.log(`  • Модулей: ${courseContent.modules.length}`);
    console.log(`  • Уроков: ${courseContent.modules.reduce((sum, m) => sum + m.lessons.length, 0)}`);
    console.log(`  • Общая продолжительность: ${courseContent.modules.reduce((sum, m) => sum + m.lessons.reduce((lessonSum, l) => lessonSum + l.duration, 0), 0)} минут`);
    
    return true;
    
  } catch (error) {
    console.error('❌ Ошибка создания курса:', error);
    throw error;
  }
}

// Запуск создания курса
createPromptEngineeringCourse()
  .then(() => {
    console.log('✅ Скрипт завершен успешно');
    process.exit(0);
  })
  .catch((error) => {
    console.error('❌ Ошибка выполнения скрипта:', error);
    process.exit(1);
  });

export { createPromptEngineeringCourse };